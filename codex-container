#!/usr/bin/env bash
#
# Codex Container Launcher
# A convenient script to run OpenAI Codex in an isolated Docker container
#
# Usage:
#   codex-container [options] [command]
#
# Notes:
#   - Leading flags default to codex (e.g. `codex-container --search`)
#   - Workspace is mounted at /workspace and workdir mirrors your host subdirectory when possible
#

set -euo pipefail

# --------------------------
# Globals
# --------------------------

# Color codes for output
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
CYAN=$'\033[0;36m'
MAGENTA=$'\033[0;35m'
NC=$'\033[0m' # No Color

SCRIPT_DIR=""
DEFAULT_VERSION="1.3.3"
VERSION=""

HOST_PWD="$(pwd -P)"
WORKSPACE_DIR_DEFAULT="$(pwd)"
CONFIG_HOME_DEFAULT="$HOME/.config/codex-container"
CONFIG_DIR_DEFAULT="$CONFIG_HOME_DEFAULT/config"

WORKSPACE_DIR=""
CONFIG_DIR=""
IMAGE_NAME=""
CONTAINER_NAME=""
WORKSPACE_EXPLICIT="false"
PREFER_LAST_CONTAINER="false"
CONTAINER_NAME_EXPLICIT="false"
WORKSPACE_CLI_EXPLICIT="false"

ENV_FILE=""
DEBUG_MODE="false"
HOST_CODEX_DIR="false"
ALLOW_SUDO="false"
EPHEMERAL="false"
ALLOW_DOCKER="false"
DRY_RUN="false"
PRUNE_YES="false"

# Command payloads (argv-safe)
ENV_ARRAY=()
NPM_ARGS=()
NPX_ARGS=()
CODEX_ARGS=()
PIPX_ARGS=()
MCP_ARGS=()
EXEC_ARGS=()
COMMAND_ARGS=()
AGENT_COMMAND_ARGS=()

ACTION=""
EXEC_COMMAND_STRING=""
NODE_FILE=""
HOST_RELATIVE=""

AGENT_DOCKER="false"
AGENT_IMAGE_NAME=""
AGENT_CONTAINER_NAME=""
AGENT_WORKSPACE_DIR=""
AGENT_CONFIG_DIR=""
AGENT_WORKSPACE_EXPLICIT="false"
AGENT_CONFIG_EXPLICIT="false"
AGENT_SHELL="false"
AGENT_ROOT="false"
AGENT_SSH_AUTH_SOCK="auto"
AGENT_ENV_ARRAY=()
AGENT_ENV_FILE=""

# --------------------------
# Helpers
# --------------------------

fail() {
    echo -e "${RED}Error:${NC} $*" >&2
    exit 1
}

info() {
    echo -e "${BLUE}$*${NC}"
}

warn() {
    echo -e "${YELLOW}Warning:${NC} $*"
}

print_dry_run() {
    printf 'DRY RUN: '
    printf '%q ' "$@"
    printf '\n'
}

resolve_script_dir() {
    local source="${BASH_SOURCE[0]}"
    if command -v readlink >/dev/null 2>&1; then
        local resolved
        resolved="$(readlink -f "$source" 2>/dev/null || true)"
        if [ -n "$resolved" ]; then
            source="$resolved"
        fi
    fi
    while [ -h "$source" ]; do
        local dir
        dir="$(cd -P "$(dirname "$source")" && pwd)"
        local link
        link="$(readlink "$source")"
        if [[ "$link" == /* ]]; then
            source="$link"
        else
            source="$dir/$link"
        fi
    done
    cd -P "$(dirname "$source")" >/dev/null 2>&1
    pwd
}

load_version() {
    SCRIPT_DIR="$(resolve_script_dir)"
    VERSION="$DEFAULT_VERSION"
    for candidate in \
        "$SCRIPT_DIR/VERSION" \
        "$HOME/.local/share/codex-container/VERSION" \
        "/usr/local/share/codex-container/VERSION"; do
        if [ -s "$candidate" ]; then
            VERSION="$(cat "$candidate")"
            return
        fi
    done
}

expand_tilde() {
    local path="$1"
    if [[ "$path" == "~" ]]; then
        echo "$HOME"
        return
    fi
    if [[ "$path" == ~/* ]]; then
        echo "${path/#\~/$HOME}"
        return
    fi
    echo "$path"
}

abs_path() {
    local path="$1"
    path="$(expand_tilde "$path")"
    if [ -d "$path" ]; then
        (cd "$path" && pwd -P)
        return
    fi
    local dir
    dir="$(dirname "$path")"
    local base
    base="$(basename "$path")"
    if [ -d "$dir" ]; then
        local abs_dir
        abs_dir="$(cd "$dir" && pwd -P)"
        echo "$abs_dir/$base"
    else
        echo "$path"
    fi
}

hash_path() {
    local input="$1"
    if command -v sha256sum >/dev/null 2>&1; then
        printf '%s' "$input" | sha256sum | awk '{print $1}'
        return
    fi
    if command -v shasum >/dev/null 2>&1; then
        printf '%s' "$input" | shasum -a 256 | awk '{print $1}'
        return
    fi
    if command -v md5sum >/dev/null 2>&1; then
        printf '%s' "$input" | md5sum | awk '{print $1}'
        return
    fi
    if command -v md5 >/dev/null 2>&1; then
        printf '%s' "$input" | md5 -q
        return
    fi
    printf '%s' "$input" | cksum | awk '{print $1}'
}

container_exists() {
    docker container inspect "$1" >/dev/null 2>&1
}

container_running() {
    local state
    state="$(docker inspect -f '{{.State.Running}}' "$1" 2>/dev/null || true)"
    [ "$state" = "true" ]
}

image_exists() {
    docker image inspect "$1" >/dev/null 2>&1
}

get_container_label() {
    local container="$1"
    local key="$2"
    docker inspect -f "{{ index .Config.Labels \"$key\" }}" "$container" 2>/dev/null || true
}

ensure_docker() {
    if [ "$DRY_RUN" = "true" ]; then
        return
    fi
    if ! docker info >/dev/null 2>&1; then
        fail "Docker is not running or not accessible. Please start Docker and try again."
    fi
}

ensure_image() {
    if ! image_exists "$IMAGE_NAME"; then
        warn "Image not found. Building..."
        build_image
    fi
}

state_dir() {
    local base
    base="${CONFIG_HOME_DEFAULT}"
    if [ -n "${CONFIG_DIR:-}" ]; then
        base="$(dirname "$CONFIG_DIR")"
    fi
    echo "$base/state"
}

last_container_file() {
    echo "$(state_dir)/last_container"
}

set_last_container() {
    local path
    path="$(last_container_file)"
    mkdir -p "$(dirname "$path")"
    echo "$1" > "$path"
}

get_last_container() {
    local path
    path="$(last_container_file)"
    if [ -f "$path" ]; then
        cat "$path"
    fi
}

resolve_workspace() {
    if [ "$WORKSPACE_EXPLICIT" = "true" ] && [ -n "${WORKSPACE_DIR:-}" ]; then
        WORKSPACE_DIR="$(expand_tilde "$WORKSPACE_DIR")"
        if [ -d "$WORKSPACE_DIR" ]; then
            WORKSPACE_DIR="$(cd "$WORKSPACE_DIR" && pwd -P)"
        fi
        return
    fi
    if [ -n "${CODEX_WORKSPACE:-}" ]; then
        WORKSPACE_EXPLICIT="true"
        WORKSPACE_DIR="$CODEX_WORKSPACE"
    else
        WORKSPACE_DIR="$WORKSPACE_DIR_DEFAULT"
    fi
    WORKSPACE_DIR="$(expand_tilde "$WORKSPACE_DIR")"
    if [ -n "$WORKSPACE_DIR" ] && [ -d "$WORKSPACE_DIR" ]; then
        WORKSPACE_DIR="$(cd "$WORKSPACE_DIR" && pwd -P)"
    fi
}

resolve_config_dir() {
    if [ -n "${CONFIG_DIR:-}" ]; then
        CONFIG_DIR="$(expand_tilde "$CONFIG_DIR")"
        CONFIG_DIR="$(abs_path "$CONFIG_DIR")"
        return
    fi
    CONFIG_DIR="${CODEX_CONFIG:-$CONFIG_DIR_DEFAULT}"
    CONFIG_DIR="$(expand_tilde "$CONFIG_DIR")"
    CONFIG_DIR="$(abs_path "$CONFIG_DIR")"
}

resolve_image_name() {
    local default_image="codex-container:${VERSION}"
    IMAGE_NAME="${CODEX_IMAGE:-$default_image}"
}

resolve_agent_image_name() {
    if [ -n "$AGENT_IMAGE_NAME" ]; then
        return
    fi
    local default_image="codex-container-agent:${VERSION}"
    AGENT_IMAGE_NAME="${default_image}"
}

resolve_agent_workspace() {
    if [ "$AGENT_WORKSPACE_EXPLICIT" = "true" ] && [ -n "${AGENT_WORKSPACE_DIR:-}" ]; then
        AGENT_WORKSPACE_DIR="$(expand_tilde "$AGENT_WORKSPACE_DIR")"
        if [ -d "$AGENT_WORKSPACE_DIR" ]; then
            AGENT_WORKSPACE_DIR="$(cd "$AGENT_WORKSPACE_DIR" && pwd -P)"
        fi
        return
    fi
    AGENT_WORKSPACE_DIR="$HOST_PWD"
    AGENT_WORKSPACE_DIR="$(expand_tilde "$AGENT_WORKSPACE_DIR")"
    if [ -d "$AGENT_WORKSPACE_DIR" ]; then
        AGENT_WORKSPACE_DIR="$(cd "$AGENT_WORKSPACE_DIR" && pwd -P)"
    fi
}

resolve_agent_config_dir() {
    if [ "$AGENT_CONFIG_EXPLICIT" = "true" ] && [ -n "${AGENT_CONFIG_DIR:-}" ]; then
        AGENT_CONFIG_DIR="$(expand_tilde "$AGENT_CONFIG_DIR")"
        AGENT_CONFIG_DIR="$(abs_path "$AGENT_CONFIG_DIR")"
        return
    fi
    AGENT_CONFIG_DIR="$CONFIG_DIR"
}

default_agent_container_name() {
    if [ -n "$AGENT_WORKSPACE_DIR" ]; then
        local hash
        hash="$(hash_path "$AGENT_WORKSPACE_DIR")"
        if [ -z "$hash" ]; then
            fail "Unable to derive agent container name from workspace path."
        fi
        echo "codex-agent-${hash:0:12}"
        return
    fi
    echo "codex-agent-runtime"
}

resolve_agent_container_name() {
    if [ -n "$AGENT_CONTAINER_NAME" ]; then
        echo "$AGENT_CONTAINER_NAME"
        return
    fi
    default_agent_container_name
}

default_container_name() {
    if [ -n "$WORKSPACE_DIR" ]; then
        local hash
        hash="$(hash_path "$WORKSPACE_DIR")"
        if [ -z "$hash" ]; then
            fail "Unable to derive container name from workspace path."
        fi
        echo "codex-container-${hash:0:12}"
        return
    fi
    echo "codex-container-runtime"
}

resolve_container_name() {
    if [ -n "$CONTAINER_NAME" ]; then
        echo "$CONTAINER_NAME"
        return
    fi
    if [ "$PREFER_LAST_CONTAINER" = "true" ]; then
        local last
        last="$(get_last_container || true)"
        if [ -n "$last" ]; then
            warn "No workspace provided. Using last container: $last"
            echo "$last"
            return
        fi
    fi
    if [ -n "$WORKSPACE_DIR" ]; then
        default_container_name
        return
    fi
    local last
    last="$(get_last_container || true)"
    if [ -n "$last" ]; then
        warn "No workspace provided. Using last container: $last"
        echo "$last"
        return
    fi
    fail "Container name not resolved. Provide --workspace or --name."
}

resolve_host_relative() {
    HOST_RELATIVE=""
    if [ -n "$WORKSPACE_DIR" ]; then
        if [[ "$HOST_PWD" == "$WORKSPACE_DIR" ]]; then
            HOST_RELATIVE=""
        elif [[ "$HOST_PWD" == "$WORKSPACE_DIR/"* ]]; then
            HOST_RELATIVE="${HOST_PWD#"$WORKSPACE_DIR/"}"
        fi
    fi
}

normalize_env_file() {
    if [ -n "$ENV_FILE" ] && [ -f "$ENV_FILE" ]; then
        ENV_FILE="$(abs_path "$ENV_FILE")"
    fi
}

normalize_agent_env_file() {
    if [ -n "$AGENT_ENV_FILE" ] && [ -f "$AGENT_ENV_FILE" ]; then
        AGENT_ENV_FILE="$(abs_path "$AGENT_ENV_FILE")"
    fi
}

autoload_env_file() {
    if [ -n "$ENV_FILE" ]; then
        return
    fi
    if [ -z "$WORKSPACE_DIR" ]; then
        return
    fi
    if [ -n "$HOST_RELATIVE" ] && [ -f "$HOST_PWD/.env" ]; then
        ENV_FILE="$HOST_PWD/.env"
        return
    fi
    if [ -f "$WORKSPACE_DIR/.env" ]; then
        ENV_FILE="$WORKSPACE_DIR/.env"
    fi
}

load_env_file_into_array() {
    local file="$1"
    if [ ! -f "$file" ]; then
        return
    fi
    while IFS= read -r line || [ -n "$line" ]; do
        if [ -z "$line" ]; then
            continue
        fi
        if [[ "$line" == \#* ]]; then
            continue
        fi
        if [[ "$line" == export* ]]; then
            line="${line#export }"
        fi
        if [[ "$line" == *=* ]]; then
            ENV_ARRAY+=("$line")
        fi
    done < "$file"
}

load_env_file_into_agent_array() {
    local file="$1"
    if [ ! -f "$file" ]; then
        return
    fi
    while IFS= read -r line || [ -n "$line" ]; do
        if [ -z "$line" ]; then
            continue
        fi
        if [[ "$line" == \#* ]]; then
            continue
        fi
        if [[ "$line" == export* ]]; then
            line="${line#export }"
        fi
        if [[ "$line" == *=* ]]; then
            AGENT_ENV_ARRAY+=("$line")
        fi
    done < "$file"
}

collect_git_identity() {
    local name=""
    local email=""
    if [ -n "${CODEX_GIT_NAME:-}" ]; then
        name="$CODEX_GIT_NAME"
    elif [ -n "${GIT_USER_NAME:-}" ]; then
        name="$GIT_USER_NAME"
    elif command -v git >/dev/null 2>&1; then
        name="$(git config --global user.name 2>/dev/null || true)"
    fi

    if [ -n "${CODEX_GIT_EMAIL:-}" ]; then
        email="$CODEX_GIT_EMAIL"
    elif [ -n "${GIT_USER_EMAIL:-}" ]; then
        email="$GIT_USER_EMAIL"
    elif command -v git >/dev/null 2>&1; then
        email="$(git config --global user.email 2>/dev/null || true)"
    fi
    ENV_ARRAY+=("CODEX_GIT_NAME=$name")
    ENV_ARRAY+=("CODEX_GIT_EMAIL=$email")

    if [ -z "$name" ] || [ -z "$email" ]; then
        local marker
        marker="$(state_dir)/git-identity-warning"
        if [ ! -f "$marker" ]; then
            warn "Host git identity not fully set (user.name or user.email missing)."
            mkdir -p "$(dirname "$marker")" 2>/dev/null || true
            touch "$marker" 2>/dev/null || true
        fi
    fi
}

print_startup_info() {
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}  Starting Codex Container v${VERSION}  ${NC}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    if [ -n "$WORKSPACE_DIR" ]; then
        echo -e "${BLUE}Workspace:${NC} ${YELLOW}$WORKSPACE_DIR${NC}"
    fi
    echo -e "${BLUE}Config:${NC}    ${YELLOW}$CONFIG_DIR${NC}"
    echo -e "${BLUE}Container:${NC} ${YELLOW}$CONTAINER_NAME${NC}"
    if [ -n "$ENV_FILE" ]; then
        echo -e "${BLUE}Env file:${NC}  ${YELLOW}$ENV_FILE${NC}"
    fi
    if [ "$ALLOW_SUDO" = "true" ]; then
        echo -e "${BLUE}Sudo:${NC}      ${YELLOW}enabled${NC}"
    else
        echo -e "${BLUE}Sudo:${NC}      ${YELLOW}disabled${NC}"
    fi
    if [ "$ALLOW_DOCKER" = "true" ]; then
        echo -e "${BLUE}Docker:${NC}    ${YELLOW}enabled${NC}"
    else
        echo -e "${BLUE}Docker:${NC}    ${YELLOW}disabled${NC}"
    fi
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
}

show_help() {
    cat << EOF
${GREEN}Codex Container Launcher v${VERSION}${NC}
An isolated Docker environment for OpenAI Codex and Node.js development

${YELLOW}USAGE:${NC}
    codex-container [OPTIONS] [COMMAND]
    codex-container <subcommand> [OPTIONS]

${YELLOW}OPTIONS:${NC}
    ${CYAN}-w, --workspace <path>${NC}      Set workspace directory (default: current directory)
    ${CYAN}-c, --config <path>${NC}         Set config directory (default: \$HOME/.config/codex-container/config)
    ${CYAN}-n, --name <name>${NC}           Set container name (default: workspace-scoped)
    ${CYAN}-e, --env <KEY=VALUE>${NC}       Set environment variable in container (repeatable)
    ${CYAN}--env-file <path>${NC}           Load environment variables from a .env-style file
    ${CYAN}--agent-docker${NC}              Enable host docker socket passthrough for agent container
    ${CYAN}--agent-image <image>${NC}       Set agent container image (default: codex-container-agent:VERSION)
    ${CYAN}--agent-shell${NC}               Open a shell in the agent container
    ${CYAN}--agent-workspace <path>${NC}    Set agent workspace directory (default: current directory)
    ${CYAN}--agent-config <path>${NC}       Set agent config directory (default: runtime config dir)
    ${CYAN}--agent-ssh-auth-sock${NC}       Forward SSH_AUTH_SOCK into the agent container
    ${CYAN}--agent-env <KEY=VALUE>${NC}     Set env var in agent container (repeatable)
    ${CYAN}--agent-env-file <path>${NC}     Load agent env vars from a .env-style file
    ${CYAN}--agent-root${NC}                Run agent container as root (required for some docker.sock setups)
    ${CYAN}--host-codex-dir${NC}            (Optional) Mount host ~/.codex for auth/state instead of /config persistence
    ${CYAN}--allow-sudo${NC}                Allow sudo/apk in the runtime container (opt-in, at start time)
    ${CYAN}--allow-docker${NC}              Allow runtime container access to host Docker socket (opt-in)
    ${CYAN}--ephemeral${NC}                 Run a one-shot container (legacy --rm behavior)
    ${CYAN}--debug${NC}                     Print resolved docker invocation (no secrets redacted)
    ${CYAN}--dry-run${NC}                   Print docker commands without running them
    ${CYAN}--yes${NC}                       Auto-confirm prompts (for prune-images)
    ${CYAN}-h, --help${NC}                  Show this help message
    ${CYAN}--version${NC}                   Show version information

${YELLOW}SUBCOMMANDS:${NC}
    ${CYAN}start${NC}                       Create or ensure the runtime container exists
    ${CYAN}stop${NC}                        Stop the runtime container
    ${CYAN}rm${NC}                          Remove the runtime container
    ${CYAN}clean${NC}                       Remove runtime container and image
    ${CYAN}status${NC}                      Check container status
    ${CYAN}shell${NC}                       Open interactive shell in runtime container
    ${CYAN}exec -- <command>${NC}           Execute command in runtime container
    ${CYAN}logs${NC}                        Show container logs
    ${CYAN}agent -- <command>${NC}          Execute command in agent container (defaults to shell)
    ${CYAN}prune-images${NC}                Remove old codex-container images (keeps current version)

${YELLOW}SHORTCUTS:${NC}
    ${CYAN}codex [args]${NC}                Run codex (default target when args start with '-')
    ${CYAN}npm [args]${NC}                  Run npm command
    ${CYAN}npx [args]${NC}                  Run npx command
    ${CYAN}node <file>${NC}                 Run Node.js script
    ${CYAN}pipx [args]${NC}                 Run pipx in the runtime container
    ${CYAN}mcp [args]${NC}                  Run codex mcp commands in the runtime container

${YELLOW}EXAMPLES:${NC}
    ${BLUE}# Start a persistent runtime container${NC}
    codex-container start

    ${BLUE}# Run codex (starts container if needed)${NC}
    codex-container --search

    ${BLUE}# Use a custom workspace${NC}
    codex-container -w /path/to/project start

    ${BLUE}# Open interactive shell${NC}
    codex-container shell

    ${BLUE}# Run in ephemeral mode${NC}
    codex-container --ephemeral --search

    ${BLUE}# Run a command in an agent container with Docker access${NC}
    codex-container agent --agent-docker -- ./scripts/smoke.sh

    ${BLUE}# Prune older codex-container images${NC}
    codex-container prune-images --yes

${YELLOW}ENVIRONMENT VARIABLES:${NC}
    ${CYAN}CODEX_WORKSPACE${NC}        Override default workspace directory
    ${CYAN}CODEX_CONFIG${NC}           Override default config directory
    ${CYAN}CODEX_IMAGE${NC}            Override default Docker image name
    ${CYAN}OPENAI_API_KEY${NC}         OpenAI API key for Codex
    ${CYAN}CODEX_GIT_NAME${NC}         Git user name (set inside container)
    ${CYAN}CODEX_GIT_EMAIL${NC}        Git user email (set inside container)
    ${CYAN}CODEX_HOST_PWD${NC}         Host working directory (passed into container)
    ${CYAN}CODEX_HOST_WORKSPACE${NC}   Host workspace root path (passed into container)
    ${CYAN}CODEX_HOST_RELATIVE${NC}    Host relative path within workspace (passed into container)

${YELLOW}CONFIGURATION:${NC}
    Configuration is persisted in: ${CONFIG_DIR_DEFAULT}

    Codex state/config is persisted under:
    ${CONFIG_DIR_DEFAULT}/codex

    To save OpenAI API key permanently:
    echo "sk-your-key" > ${CONFIG_DIR_DEFAULT}/openai_key

${YELLOW}NOTES:${NC}
    - Workspace is mounted at /workspace in the container (and workdir mirrors your host subdirectory when possible)
    - Configuration is mounted at /config in the container
    - Global npm packages are preserved across sessions
    - Default mode does not allow sudo or apk installs. Use --allow-sudo to opt in.
    - Use --allow-docker to expose the host Docker socket to the runtime container.

${GREEN}For more information, see README.md${NC}
EOF
}

show_version() {
    echo -e "${GREEN}Codex Container${NC}"
    echo -e "Version: ${YELLOW}${VERSION}${NC}"
    echo -e "Image:   ${YELLOW}${IMAGE_NAME}${NC}"
    if docker info >/dev/null 2>&1; then
        if image_exists "$IMAGE_NAME"; then
            echo -e "Status:  ${GREEN}Image built${NC}"
        else
            echo -e "Status:  ${YELLOW}Image not built (run start or --build)${NC}"
        fi
    else
        echo -e "Status:  ${YELLOW}Image status unavailable (docker not running)${NC}"
    fi
}

# --------------------------
# Docker operations
# --------------------------

build_image() {
    echo -e "${GREEN}Building Codex Container image...${NC}"

    if [ ! -f "$SCRIPT_DIR/Dockerfile" ]; then
        fail "Dockerfile not found in $SCRIPT_DIR. If you installed a symlink, run from the repo or set CODEX_IMAGE."
    fi

    if [ "$DRY_RUN" = "true" ]; then
        print_dry_run docker build --build-arg "CODEX_VERSION=$VERSION" -t "$IMAGE_NAME" "$SCRIPT_DIR"
        return
    fi

    (cd "$SCRIPT_DIR" && docker build --build-arg CODEX_VERSION="$VERSION" -t "$IMAGE_NAME" .) || {
        fail "Failed to build image"
    }

    echo -e "${GREEN}Image built successfully: ${IMAGE_NAME}${NC}"
}

build_agent_image() {
    echo -e "${GREEN}Building Codex Agent image...${NC}"

    if [ ! -f "$SCRIPT_DIR/Dockerfile.agent" ]; then
        fail "Dockerfile.agent not found in $SCRIPT_DIR. If you installed a symlink, run from the repo or set --agent-image."
    fi

    if [ "$DRY_RUN" = "true" ]; then
        print_dry_run docker build --build-arg "CODEX_VERSION=$VERSION" -f "$SCRIPT_DIR/Dockerfile.agent" -t "$AGENT_IMAGE_NAME" "$SCRIPT_DIR"
        return
    fi

    (cd "$SCRIPT_DIR" && docker build --build-arg CODEX_VERSION="$VERSION" -f Dockerfile.agent -t "$AGENT_IMAGE_NAME" .) || {
        fail "Failed to build agent image"
    }

    echo -e "${GREEN}Agent image built successfully: ${AGENT_IMAGE_NAME}${NC}"
}

ensure_agent_image() {
    if ! image_exists "$AGENT_IMAGE_NAME"; then
        warn "Agent image not found. Building..."
        build_agent_image
    fi
}

create_config_dirs() {
    mkdir -p "$CONFIG_DIR" || true
    mkdir -p "$CONFIG_DIR/npm" "$CONFIG_DIR/codex" "$CONFIG_DIR/history" "$CONFIG_DIR/pipx" "$CONFIG_DIR/pip-cache" "$CONFIG_DIR/git" || true
}

runtime_docker_args() {
    local -a args=()
    args+=( --init )
    args+=( --name "$CONTAINER_NAME" )
    args+=( --label "com.codex.workspace=$WORKSPACE_DIR" )
    args+=( --label "com.codex.allow_sudo=$ALLOW_SUDO" )
    args+=( --label "com.codex.allow_docker=$ALLOW_DOCKER" )
    args+=( --network host )
    args+=( -v "$WORKSPACE_DIR:/workspace" )
    args+=( -v "$CONFIG_DIR:/config" )
    args+=( -v codex-npm-global:/home/codex/.npm-global )
    if [ "$HOST_CODEX_DIR" = "true" ]; then
        mkdir -p "$HOME/.codex" 2>/dev/null || true
        chmod 755 "$HOME/.codex" 2>/dev/null || true
        args+=( -v "$HOME/.codex:/home/codex/.codex" )
    fi
    if [ -n "${SSH_AUTH_SOCK:-}" ] && [ -S "${SSH_AUTH_SOCK:-}" ]; then
        args+=( -v "$SSH_AUTH_SOCK:/ssh-agent" )
        args+=( -e "SSH_AUTH_SOCK=/ssh-agent" )
    fi
    args+=( -e "USER_UID=$(id -u)" )
    args+=( -e "USER_GID=$(id -g)" )
    args+=( -e "ALLOW_SUDO=$ALLOW_SUDO" )
    args+=( -e "PIPX_HOME=/config/pipx" )
    args+=( -e "PIPX_BIN_DIR=/config/pipx/bin" )
    args+=( -e "PIP_CACHE_DIR=/config/pip-cache" )
    for env in "${ENV_ARRAY[@]}"; do
        args+=( -e "$env" )
    done
    if [ "$ALLOW_DOCKER" = "true" ]; then
        if [ ! -S /var/run/docker.sock ]; then
            fail "Docker socket not found at /var/run/docker.sock"
        fi
        args+=( -v /var/run/docker.sock:/var/run/docker.sock )
        local gid
        gid="$(docker_sock_gid)"
        if [ -n "$gid" ]; then
            args+=( --group-add "$gid" )
        else
            warn "Unable to detect docker.sock group; access may fail."
        fi
    fi
    echo "${args[@]}"
}

start_container() {
    if [ "$DRY_RUN" = "true" ]; then
        create_config_dirs
        local -a args
        read -r -a args <<< "$(runtime_docker_args)"
        if [ "$ALLOW_SUDO" != "true" ]; then
            args+=( --security-opt=no-new-privileges )
        fi
        if [ "$ALLOW_DOCKER" = "true" ]; then
            warn "Enabling docker socket gives this container control of the host Docker daemon."
        fi
        print_dry_run docker run -d "${args[@]}" "$IMAGE_NAME" sleep infinity
        return
    fi

    ensure_image
    create_config_dirs

    if container_exists "$CONTAINER_NAME"; then
        local existing_allow
        existing_allow="$(get_container_label "$CONTAINER_NAME" "com.codex.allow_sudo")"
        local existing_docker
        existing_docker="$(get_container_label "$CONTAINER_NAME" "com.codex.allow_docker")"
        if [ "$ALLOW_SUDO" = "true" ] && [ "$existing_allow" = "false" ]; then
            fail "Container exists without --allow-sudo. Remove it with: $0 rm, then re-run: $0 --allow-sudo start"
        fi
        if [ "$ALLOW_SUDO" != "true" ] && [ "$existing_allow" = "true" ]; then
            warn "Container was created with --allow-sudo enabled."
        fi
        if [ -z "$existing_allow" ]; then
            warn "Existing container missing allow-sudo label; proceeding without mismatch enforcement."
        fi
        if [ "$ALLOW_DOCKER" = "true" ] && [ "$existing_docker" = "false" ]; then
            fail "Container exists without --allow-docker. Remove it with: $0 rm, then re-run: $0 --allow-docker start"
        fi
        if [ "$ALLOW_DOCKER" != "true" ] && [ "$existing_docker" = "true" ]; then
            warn "Container was created with --allow-docker enabled."
        fi
        if [ -z "$existing_docker" ]; then
            warn "Existing container missing allow-docker label; proceeding without mismatch enforcement."
        fi
        if ! container_running "$CONTAINER_NAME"; then
            echo -e "${YELLOW}Starting existing container...${NC}"
            docker start "$CONTAINER_NAME" >/dev/null
        fi
        set_last_container "$CONTAINER_NAME"
        return
    fi

    print_startup_info

    if [ -z "${SSH_AUTH_SOCK:-}" ] || [ ! -S "${SSH_AUTH_SOCK:-}" ]; then
        warn "SSH agent not detected. Set SSH_AUTH_SOCK to enable agent forwarding."
    fi
    if [ "$ALLOW_DOCKER" = "true" ]; then
        warn "Enabling docker socket gives this container control of the host Docker daemon."
    fi

    local -a args
    read -r -a args <<< "$(runtime_docker_args)"

    if [ "$ALLOW_SUDO" != "true" ]; then
        args+=( --security-opt=no-new-privileges )
    fi

    if [ "$DEBUG_MODE" = "true" ]; then
        echo -e "${MAGENTA}DEBUG: docker run invocation:${NC}"
        printf '%q ' docker run -d "${args[@]}" "$IMAGE_NAME" sleep infinity
        echo
        echo
    fi

    docker run -d "${args[@]}" "$IMAGE_NAME" sleep infinity >/dev/null
    set_last_container "$CONTAINER_NAME"
    echo -e "${GREEN}Runtime container ready: ${CONTAINER_NAME}${NC}"
}

stop_container() {
    if container_running "$CONTAINER_NAME"; then
        echo -e "${YELLOW}Stopping container...${NC}"
        docker stop "$CONTAINER_NAME" >/dev/null
    else
        warn "Container is not running"
    fi
}

remove_container() {
    if container_exists "$CONTAINER_NAME"; then
        echo -e "${YELLOW}Removing container...${NC}"
        docker rm -f "$CONTAINER_NAME" >/dev/null
        echo -e "${GREEN}Container removed${NC}"
    else
        warn "Container does not exist"
    fi
}

clean_all() {
    remove_container
    if image_exists "$IMAGE_NAME"; then
        echo -e "${YELLOW}Removing image...${NC}"
        docker rmi "$IMAGE_NAME" 2>/dev/null || true
        echo -e "${GREEN}Image removed${NC}"
    fi
}

check_status() {
    echo -e "${CYAN}Container Status:${NC}"
    if [ "$DEBUG_MODE" = "true" ]; then
        echo -e "  Resolved:  ${BLUE}${CONTAINER_NAME}${NC}"
    fi

    if image_exists "$IMAGE_NAME"; then
        echo -e "  Image:     ${GREEN}Built${NC} (${IMAGE_NAME})"
    else
        echo -e "  Image:     ${YELLOW}Not built${NC} (run start or --build)"
    fi

    if container_running "$CONTAINER_NAME"; then
        echo -e "  Container: ${GREEN}Running${NC} (${CONTAINER_NAME})"
        local container_id
        local uptime
        container_id="$(docker inspect -f '{{.Id}}' "$CONTAINER_NAME" 2>/dev/null || true)"
        uptime="$(docker inspect -f '{{.State.Status}} ({{.State.StartedAt}})' "$CONTAINER_NAME" 2>/dev/null || true)"
        echo -e "  ID:        ${BLUE}${container_id}${NC}"
        echo -e "  Uptime:    ${BLUE}${uptime}${NC}"
        echo -e "  Volumes:"
        docker inspect "$CONTAINER_NAME" --format='{{range .Mounts}}    {{.Source}} -> {{.Destination}}{{println}}{{end}}' 2>/dev/null || true
    elif container_exists "$CONTAINER_NAME"; then
        echo -e "  Container: ${YELLOW}Stopped${NC} (${CONTAINER_NAME})"
    else
        echo -e "  Container: ${BLUE}Not created${NC}"
    fi
}

show_logs() {
    if container_running "$CONTAINER_NAME"; then
        docker logs -f "$CONTAINER_NAME"
    else
        fail "Container is not running. Start it with: $0 start"
    fi
}

exec_in_container() {
    local -a cmd=("$@")
    local -a exec_args=()
    local workdir=""
    local tty_flag="-it"

    if [ ! -t 0 ] || [ ! -t 1 ]; then
        tty_flag="-i"
    fi

    if [ -n "$WORKSPACE_DIR" ]; then
        workdir="/workspace"
        if [ -n "$HOST_RELATIVE" ]; then
            workdir="/workspace/$HOST_RELATIVE"
        fi
    fi

    exec_args+=( -e "CODEX_HOST_PWD=$HOST_PWD" )
    exec_args+=( -e "CODEX_HOST_WORKSPACE=$WORKSPACE_DIR" )
    exec_args+=( -e "CODEX_HOST_RELATIVE=$HOST_RELATIVE" )

    for env in "${ENV_ARRAY[@]}"; do
        exec_args+=( -e "$env" )
    done

    if [ -n "$workdir" ]; then
        exec_args+=( -w "$workdir" )
    fi

    if [ "$DEBUG_MODE" = "true" ]; then
        echo -e "${MAGENTA}DEBUG: docker exec invocation:${NC}"
        printf '%q ' docker exec "$tty_flag" "${exec_args[@]}" "$CONTAINER_NAME" "${cmd[@]}"
        echo
        echo
    fi

    if [ "$DRY_RUN" = "true" ]; then
        print_dry_run docker exec "$tty_flag" "${exec_args[@]}" "$CONTAINER_NAME" "${cmd[@]}"
        return
    fi

    docker exec "$tty_flag" "${exec_args[@]}" "$CONTAINER_NAME" "${cmd[@]}"
}

docker_sock_gid() {
    if [ -S /var/run/docker.sock ]; then
        stat -c %g /var/run/docker.sock 2>/dev/null || true
    fi
}

run_agent_container() {
    local -a cmd=("$@")
    local -a run=( docker run --rm --init )
    local -a env_args=()
    local -a vol_args=()
    local -a docker_args=()
    local tty_flag="-it"

    if [ ! -t 0 ] || [ ! -t 1 ]; then
        tty_flag="-i"
    fi

    ensure_agent_image

    if [ -z "$AGENT_CONTAINER_NAME" ]; then
        AGENT_CONTAINER_NAME="$(resolve_agent_container_name)"
    fi

    if [ -z "$AGENT_WORKSPACE_DIR" ]; then
        fail "Agent workspace directory is required. Use --agent-workspace."
    fi

    if [ -n "$AGENT_CONFIG_DIR" ]; then
        mkdir -p "$AGENT_CONFIG_DIR" || true
    fi

    if [ "$AGENT_DOCKER" = "true" ]; then
        echo "Warning: --agent-docker grants this container control of the host Docker daemon."
        if [ ! -S /var/run/docker.sock ]; then
            fail "Docker socket not found at /var/run/docker.sock"
        fi
        vol_args+=( -v /var/run/docker.sock:/var/run/docker.sock )
        if [ "$AGENT_ROOT" != "true" ]; then
            local gid
            gid="$(docker_sock_gid)"
            if [ -n "$gid" ]; then
                docker_args+=( --group-add "$gid" )
            else
                warn "Unable to detect docker.sock group; access may fail without --agent-root."
            fi
        fi
    fi

    if [ "$AGENT_ROOT" = "true" ]; then
        run+=( --user 0:0 )
    else
        run+=( --user "$(id -u):$(id -g)" )
    fi

    run+=( "$tty_flag" )
    run+=( --name "$AGENT_CONTAINER_NAME" )
    run+=( --workdir "$AGENT_WORKSPACE_DIR" )

    vol_args+=( -v "$AGENT_WORKSPACE_DIR:$AGENT_WORKSPACE_DIR" )
    vol_args+=( -v "$AGENT_CONFIG_DIR:$AGENT_CONFIG_DIR" )
    vol_args+=( -v "/tmp:/tmp" )

    env_args+=( -e "CODEX_WORKSPACE=$AGENT_WORKSPACE_DIR" )
    env_args+=( -e "CODEX_CONFIG=$AGENT_CONFIG_DIR" )
    env_args+=( -e "HOME=/home/agent" )

    if [ "$AGENT_SSH_AUTH_SOCK" = "true" ] || { [ "$AGENT_SSH_AUTH_SOCK" = "auto" ] && [ -n "${SSH_AUTH_SOCK:-}" ] && [ -S "${SSH_AUTH_SOCK:-}" ]; }; then
        vol_args+=( -v "$SSH_AUTH_SOCK:/ssh-agent" )
        env_args+=( -e "SSH_AUTH_SOCK=/ssh-agent" )
    fi

    for env in "${AGENT_ENV_ARRAY[@]}"; do
        env_args+=( -e "$env" )
    done

    if [ "$DEBUG_MODE" = "true" ]; then
        echo -e "${MAGENTA}DEBUG: agent docker run invocation:${NC}"
        printf '%q ' "${run[@]}" "${docker_args[@]}" "${vol_args[@]}" "${env_args[@]}" "$AGENT_IMAGE_NAME" "${cmd[@]}"
        echo
        echo
    fi

    if [ "$DRY_RUN" = "true" ]; then
        print_dry_run "${run[@]}" "${docker_args[@]}" "${vol_args[@]}" "${env_args[@]}" "$AGENT_IMAGE_NAME" "${cmd[@]}"
        return
    fi

    "${run[@]}" "${docker_args[@]}" "${vol_args[@]}" "${env_args[@]}" "$AGENT_IMAGE_NAME" "${cmd[@]}"
}

run_ephemeral_container() {
    local -a cmd=("$@")
    local interactive="-it"
    local -a network_mode=()
    local -a extra_volumes=()
    local -a docker_args=()
    local -a env_args=()
    local workdir="/workspace"

    if [[ "${cmd[0]}" == "codex" ]]; then
        local codex_noninteractive="false"
        for arg in "${cmd[@]:1}"; do
            case "$arg" in
                --help|-h|--version|-V) codex_noninteractive="true" ;;
            esac
        done
        case "${cmd[1]:-}" in
            exec|e|completion|features|help) codex_noninteractive="true" ;;
        esac

        if [ "$codex_noninteractive" = "true" ]; then
            interactive="-i"
        else
            interactive="-it"
        fi
        network_mode=( --network host )
    elif [[ "${cmd[0]}" != "bash" ]]; then
        interactive="-i"
    fi

    create_config_dirs

    if [ "$HOST_CODEX_DIR" = "true" ]; then
        mkdir -p "$HOME/.codex" 2>/dev/null || true
        chmod 755 "$HOME/.codex" 2>/dev/null || true
        extra_volumes+=( -v "$HOME/.codex:/home/codex/.codex" )
    fi

    ensure_image

    for env in "${ENV_ARRAY[@]}"; do
        env_args+=( -e "$env" )
    done

    env_args+=( -e "CODEX_HOST_PWD=$HOST_PWD" )
    env_args+=( -e "CODEX_HOST_WORKSPACE=$WORKSPACE_DIR" )
    if [ -n "$HOST_RELATIVE" ]; then
        env_args+=( -e "CODEX_HOST_RELATIVE=$HOST_RELATIVE" )
        workdir="/workspace/$HOST_RELATIVE"
    else
        env_args+=( -e "CODEX_HOST_RELATIVE=" )
    fi

    if [ -n "$ENV_FILE" ]; then
        for env in "${ENV_ARRAY[@]}"; do
            env_args+=( -e "$env" )
        done
    fi

    if [ -n "${SSH_AUTH_SOCK:-}" ] && [ -S "${SSH_AUTH_SOCK:-}" ]; then
        extra_volumes+=( -v "$SSH_AUTH_SOCK:/ssh-agent" )
        env_args+=( -e "SSH_AUTH_SOCK=/ssh-agent" )
    fi

    if [ "$ALLOW_DOCKER" = "true" ]; then
        warn "Enabling docker socket gives this container control of the host Docker daemon."
        if [ ! -S /var/run/docker.sock ]; then
            fail "Docker socket not found at /var/run/docker.sock"
        fi
        extra_volumes+=( -v /var/run/docker.sock:/var/run/docker.sock )
        local gid
        gid="$(docker_sock_gid)"
        if [ -n "$gid" ]; then
            docker_args+=( --group-add "$gid" )
        else
            warn "Unable to detect docker.sock group; access may fail."
        fi
    fi

    local -a run=( docker run --rm --init )
    local -a interactive_args=()
    if [ -n "$interactive" ]; then
        interactive_args=( "$interactive" )
    fi
    run+=( "${interactive_args[@]}" )
    if [ "$CONTAINER_NAME_EXPLICIT" = "true" ]; then
        run+=( --name "$CONTAINER_NAME" )
    fi
    run+=( "${network_mode[@]}" )
    if [ "$ALLOW_SUDO" != "true" ]; then
        run+=( --security-opt=no-new-privileges )
    fi
    run+=( -v "$WORKSPACE_DIR:/workspace" )
    run+=( -v "$CONFIG_DIR:/config" )
    run+=( -v codex-npm-global:/home/codex/.npm-global )
    run+=( --workdir "$workdir" )
    run+=( -e "USER_UID=$(id -u)" )
    run+=( -e "USER_GID=$(id -g)" )
    run+=( -e "ALLOW_SUDO=$ALLOW_SUDO" )
    run+=( -e "PIPX_HOME=/config/pipx" )
    run+=( -e "PIPX_BIN_DIR=/config/pipx/bin" )
    run+=( -e "PIP_CACHE_DIR=/config/pip-cache" )
    run+=( "${extra_volumes[@]}" )
    run+=( "${docker_args[@]}" )
    run+=( "${env_args[@]}" )
    run+=( "$IMAGE_NAME" )
    run+=( "${cmd[@]}" )

    if [ "$DEBUG_MODE" = "true" ]; then
        echo -e "${MAGENTA}DEBUG: docker invocation:${NC}"
        printf '%q ' "${run[@]}"
        echo
        echo
    fi

    if [ "$DRY_RUN" = "true" ]; then
        print_dry_run "${run[@]}"
        return
    fi

    "${run[@]}"
}

prune_images() {
    local keep_tag="codex-container:${VERSION}"
    local -a images=()
    local line
    while IFS= read -r line; do
        [ -z "$line" ] && continue
        images+=( "$line" )
    done < <(docker images --format '{{.Repository}}:{{.Tag}} {{.ID}}' | awk '$1 ~ /^codex-container:/')

    if [ "${#images[@]}" -eq 0 ]; then
        echo "No codex-container images found."
        return
    fi

    local -a remove_tags=()
    local entry
    for entry in "${images[@]}"; do
        local tag
        tag="${entry%% *}"
        if [ "$tag" != "$keep_tag" ]; then
            remove_tags+=( "$tag" )
        fi
    done

    if [ "${#remove_tags[@]}" -eq 0 ]; then
        echo "Only current image present (${keep_tag}). Nothing to prune."
        return
    fi

    echo "Images to remove:"
    printf '  %s\n' "${remove_tags[@]}"

    if [ "$PRUNE_YES" != "true" ]; then
        if [ -t 0 ]; then
            printf 'Remove these images? [y/N] '
            read -r reply
            case "$reply" in
                y|Y|yes|YES) ;;
                *) echo "Aborted."; return ;;
            esac
        else
            fail "Confirmation required. Re-run with --yes."
        fi
    fi

    if [ "$DRY_RUN" = "true" ]; then
        print_dry_run docker rmi "${remove_tags[@]}"
        return
    fi

    docker rmi "${remove_tags[@]}"
}

# --------------------------
# Argument parsing
# --------------------------

load_version
resolve_workspace
resolve_config_dir
resolve_image_name

while [[ $# -gt 0 ]]; do
    if [ "$ACTION" = "agent" ] && [[ "${1:-}" != -* ]]; then
        AGENT_COMMAND_ARGS=( "$@" )
        break
    fi
    case "$1" in
        -h|--help) show_help; exit 0 ;;
        --version) show_version; exit 0 ;;
        -w|--workspace) WORKSPACE_DIR="$2"; WORKSPACE_EXPLICIT="true"; WORKSPACE_CLI_EXPLICIT="true"; shift 2 ;;
        -c|--config) CONFIG_DIR="$2"; shift 2 ;;
        -n|--name) CONTAINER_NAME="$2"; CONTAINER_NAME_EXPLICIT="true"; shift 2 ;;
        -e|--env) ENV_ARRAY+=("$2"); shift 2 ;;
        --env-file) ENV_FILE="$2"; shift 2 ;;
        --agent-env) AGENT_ENV_ARRAY+=("$2"); shift 2 ;;
        --agent-env-file) AGENT_ENV_FILE="$2"; shift 2 ;;
        --debug) DEBUG_MODE="true"; shift ;;
        --dry-run) DRY_RUN="true"; shift ;;
        --host-codex-dir) HOST_CODEX_DIR="true"; shift ;;
        --allow-sudo) ALLOW_SUDO="true"; shift ;;
        --allow-docker) ALLOW_DOCKER="true"; shift ;;
        --ephemeral) EPHEMERAL="true"; shift ;;
        --yes) PRUNE_YES="true"; shift ;;
        --agent-docker) AGENT_DOCKER="true"; shift ;;
        --agent-image) AGENT_IMAGE_NAME="$2"; shift 2 ;;
        --agent-shell) AGENT_SHELL="true"; shift ;;
        --agent-workspace) AGENT_WORKSPACE_DIR="$2"; AGENT_WORKSPACE_EXPLICIT="true"; shift 2 ;;
        --agent-config) AGENT_CONFIG_DIR="$2"; AGENT_CONFIG_EXPLICIT="true"; shift 2 ;;
        --agent-ssh-auth-sock) AGENT_SSH_AUTH_SOCK="true"; shift ;;
        --agent-root) AGENT_ROOT="true"; shift ;;
        --build) ACTION="build"; shift ;;
        --start) ACTION="start"; shift ;;
        --stop) ACTION="stop"; shift ;;
        --rm) ACTION="rm"; shift ;;
        --clean) ACTION="clean"; shift ;;
        --logs) ACTION="logs"; shift ;;
        --status) ACTION="status"; shift ;;
        --shell) ACTION="shell"; shift ;;
        --exec)
            ACTION="exec"
            shift
            if [ "${1:-}" = "--" ]; then
                shift
                EXEC_ARGS=( "$@" )
            else
                EXEC_COMMAND_STRING="${1:-}"
            fi
            break
            ;;
        --npm) ACTION="npm"; shift; NPM_ARGS=( "$@" ); break ;;
        --node) ACTION="node"; NODE_FILE="$2"; shift 2 ;;
        --npx) ACTION="npx"; shift; NPX_ARGS=( "$@" ); break ;;
        --codex) ACTION="codex"; shift; CODEX_ARGS=( "$@" ); break ;;
        start|stop|rm|status|shell|logs|clean|prune-images)
            if [ "$ACTION" = "agent" ]; then
                AGENT_COMMAND_ARGS=( "$@" )
                break
            fi
            ACTION="$1"; shift ;;
        agent)
            ACTION="agent"; shift ;;
        exec)
            ACTION="exec"; shift
            if [ "${1:-}" = "--" ]; then
                shift
            fi
            EXEC_ARGS=( "$@" )
            break
            ;;
        codex)
            ACTION="codex"; shift; CODEX_ARGS=( "$@" ); break ;;
        npm)
            ACTION="npm"; shift; NPM_ARGS=( "$@" ); break ;;
        npx)
            ACTION="npx"; shift; NPX_ARGS=( "$@" ); break ;;
        pipx)
            ACTION="pipx"; shift; PIPX_ARGS=( "$@" ); break ;;
        mcp)
            ACTION="mcp"; shift; MCP_ARGS=( "$@" ); break ;;
        node)
            ACTION="node"; NODE_FILE="$2"; shift 2 ;;
        --)
            shift
            if [ "$ACTION" = "agent" ]; then
                AGENT_COMMAND_ARGS=( "$@" )
            else
                COMMAND_ARGS=( "$@" )
            fi
            break
            ;;
        *)
            if [ "$ACTION" = "agent" ]; then
                AGENT_COMMAND_ARGS=( "$@" )
                break
            fi
            COMMAND_ARGS=( "$@" )
            break
            ;;
    esac
done

# Override with environment variables if set after parsing
resolve_workspace
resolve_config_dir
resolve_image_name
resolve_agent_workspace
resolve_agent_config_dir
resolve_agent_image_name

# Normalize workspace/config/env file
WORKSPACE_DIR="$(expand_tilde "$WORKSPACE_DIR")"
CONFIG_DIR="$(expand_tilde "$CONFIG_DIR")"
normalize_env_file
normalize_agent_env_file

# Determine action for leading flags default to codex
if [ -z "$ACTION" ] && [ "${#COMMAND_ARGS[@]}" -gt 0 ]; then
    case "${COMMAND_ARGS[0]}" in
        -*)
            ACTION="codex"
            CODEX_ARGS=( "${COMMAND_ARGS[@]}" )
            COMMAND_ARGS=()
            ;;
    esac
fi

# Default behavior
if [ -z "$ACTION" ] && [ "${#COMMAND_ARGS[@]}" -eq 0 ]; then
    ACTION="codex"
    CODEX_ARGS=()
fi

# Validate workspace when needed
case "$ACTION" in
    build|clean|status|stop|rm|logs|prune-images)
        ;;
    agent)
        if [ -z "$AGENT_WORKSPACE_DIR" ]; then
            fail "Agent workspace directory is required. Use --agent-workspace."
        fi
        if [ ! -d "$AGENT_WORKSPACE_DIR" ]; then
            fail "Agent workspace directory does not exist: $AGENT_WORKSPACE_DIR"
        fi
        AGENT_WORKSPACE_DIR="$(cd "$AGENT_WORKSPACE_DIR" && pwd -P)"
        if [ -n "$AGENT_CONFIG_DIR" ]; then
            AGENT_CONFIG_DIR="$(expand_tilde "$AGENT_CONFIG_DIR")"
            AGENT_CONFIG_DIR="$(abs_path "$AGENT_CONFIG_DIR")"
        fi
        ;;
    exec)
        if [ "$CONTAINER_NAME_EXPLICIT" = "true" ] && [ "$WORKSPACE_CLI_EXPLICIT" != "true" ]; then
            WORKSPACE_DIR=""
        else
            if [ -z "$WORKSPACE_DIR" ]; then
                fail "Workspace directory is required. Use --workspace or set CODEX_WORKSPACE."
            fi
            if [ ! -d "$WORKSPACE_DIR" ]; then
                fail "Workspace directory does not exist: $WORKSPACE_DIR"
            fi
            WORKSPACE_DIR="$(cd "$WORKSPACE_DIR" && pwd -P)"
            resolve_host_relative
        fi
        ;;
    *)
        if [ -z "$WORKSPACE_DIR" ]; then
            fail "Workspace directory is required. Use --workspace or set CODEX_WORKSPACE."
        fi
        if [ ! -d "$WORKSPACE_DIR" ]; then
            fail "Workspace directory does not exist: $WORKSPACE_DIR"
        fi
        WORKSPACE_DIR="$(cd "$WORKSPACE_DIR" && pwd -P)"
        resolve_host_relative
        ;;
 esac

# Autoload env file (when appropriate)
autoload_env_file
normalize_env_file

if [ -n "$ENV_FILE" ]; then
    load_env_file_into_array "$ENV_FILE"
fi

if [ -n "$AGENT_ENV_FILE" ]; then
    load_env_file_into_agent_array "$AGENT_ENV_FILE"
fi

# Add OpenAI / Git env passthrough if present on host
if [ -n "${OPENAI_API_KEY:-}" ]; then
    ENV_ARRAY+=("OPENAI_API_KEY=$OPENAI_API_KEY")
    AGENT_ENV_ARRAY+=("OPENAI_API_KEY=$OPENAI_API_KEY")
fi

# For management commands, prefer last container if workspace not explicitly set
case "$ACTION" in
    status|stop|rm|logs|clean)
        if [ "$WORKSPACE_EXPLICIT" != "true" ] && [ -z "$CONTAINER_NAME" ]; then
            PREFER_LAST_CONTAINER="true"
            WORKSPACE_DIR=""
        fi
        ;;
esac

# Check Docker availability
ensure_docker

# Resolve container metadata for actions that need it
case "$ACTION" in
    build|prune-images)
        ;;
    clean|status|stop|rm|logs)
        if [ -z "$CONTAINER_NAME" ]; then
            CONTAINER_NAME="$(resolve_container_name)"
        fi
        ;;
    agent)
        if [ -z "$AGENT_CONTAINER_NAME" ]; then
            AGENT_CONTAINER_NAME="$(resolve_agent_container_name)"
        fi
        ;;
    *)
        collect_git_identity
        if [ -z "$CONTAINER_NAME" ]; then
            CONTAINER_NAME="$(resolve_container_name)"
        fi
        ;;
esac

# Execute action
case "$ACTION" in
    build)
        build_image
        ;;
    start)
        start_container
        ;;
    stop)
        stop_container
        ;;
    rm)
        remove_container
        ;;
    clean)
        clean_all
        ;;
    prune-images)
        prune_images
        ;;
    logs)
        show_logs
        ;;
    status)
        check_status
        ;;
    shell)
        if [ "$EPHEMERAL" = "true" ]; then
            run_ephemeral_container bash
        else
            start_container
            exec_in_container bash
        fi
        ;;
    exec)
        if [ -z "$EXEC_COMMAND_STRING" ] && [ "${#EXEC_ARGS[@]}" -eq 0 ]; then
            fail "exec requires a command. Example: codex-container exec -- ls -la"
        fi
        if [ "$EPHEMERAL" = "true" ]; then
            if [ -n "$EXEC_COMMAND_STRING" ]; then
                run_ephemeral_container bash -lc "$EXEC_COMMAND_STRING"
            else
                run_ephemeral_container "${EXEC_ARGS[@]}"
            fi
        else
            start_container
            if [ -n "$EXEC_COMMAND_STRING" ]; then
                exec_in_container bash -lc "$EXEC_COMMAND_STRING"
            else
                exec_in_container "${EXEC_ARGS[@]}"
            fi
        fi
        ;;
    agent)
        if [ "$AGENT_SHELL" = "true" ] || [ "${#AGENT_COMMAND_ARGS[@]}" -eq 0 ]; then
            run_agent_container bash
        else
            run_agent_container "${AGENT_COMMAND_ARGS[@]}"
        fi
        ;;
    npm)
        if [ "$EPHEMERAL" = "true" ]; then
            run_ephemeral_container npm "${NPM_ARGS[@]}"
        else
            start_container
            exec_in_container npm "${NPM_ARGS[@]}"
        fi
        ;;
    npx)
        if [ "$EPHEMERAL" = "true" ]; then
            run_ephemeral_container npx "${NPX_ARGS[@]}"
        else
            start_container
            exec_in_container npx "${NPX_ARGS[@]}"
        fi
        ;;
    node)
        if [ -z "$NODE_FILE" ]; then
            fail "node requires a file path"
        fi
        if [ "$EPHEMERAL" = "true" ]; then
            run_ephemeral_container node "$NODE_FILE"
        else
            start_container
            exec_in_container node "$NODE_FILE"
        fi
        ;;
    pipx)
        if [ "$EPHEMERAL" = "true" ]; then
            run_ephemeral_container pipx "${PIPX_ARGS[@]}"
        else
            start_container
            exec_in_container pipx "${PIPX_ARGS[@]}"
        fi
        ;;
    mcp)
        if [ "$EPHEMERAL" = "true" ]; then
            run_ephemeral_container codex mcp "${MCP_ARGS[@]}"
        else
            start_container
            exec_in_container codex mcp "${MCP_ARGS[@]}"
        fi
        ;;
    codex)
        if [ "$EPHEMERAL" = "true" ]; then
            run_ephemeral_container codex "${CODEX_ARGS[@]}"
        else
            start_container
            exec_in_container codex "${CODEX_ARGS[@]}"
        fi
        ;;
    *)
        if [ "${#COMMAND_ARGS[@]}" -gt 0 ]; then
            if [ "$EPHEMERAL" = "true" ]; then
                run_ephemeral_container "${COMMAND_ARGS[@]}"
            else
                start_container
                exec_in_container "${COMMAND_ARGS[@]}"
            fi
        else
            if [ "$EPHEMERAL" = "true" ]; then
                run_ephemeral_container codex
            else
                start_container
                exec_in_container codex
            fi
        fi
        ;;
 esac
